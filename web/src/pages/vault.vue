<style scoped>
    .layout {
        /* border: 1px solid #d7dde4; */
        position: relative;
        border-radius: 4px;
        overflow: hidden;
        width: 100%;
        text-align: center;
    }

    .layout-content-center {
        display: inline-block;

        margin-top: 5%;

        max-width: 60%;

        margin-bottom: 20%;
    }
    .demo-spin-icon-load{
        animation: ani-demo-spin 1s linear infinite;
    }
    @keyframes ani-demo-spin {
        from { transform: rotate(0deg);}
        50%  { transform: rotate(180deg);}
        to   { transform: rotate(360deg);}
    }
</style>
<template>
    <div>
        <div class="layout">
            <div class="layout-content-center">
                <h2 style="text-align: center; margin-bottom: 10px;">            
                    <a style="margin-top: 50px !important;" href="https://github.com/refitor/selfVault">
                        <Icon type="logo-github" size="25" />
                    </a> 
                    SelfVault
                </h2>
                <h4 style="text-align: center; color: green;">Ebalance: {{ formatEwalletBalance }}</h4>
                <h4 style="text-align: center; color: orangered;">Eaddress: {{ formatEwalletAddress }}</h4>
                <h4 v-show="sentTxHash !== ''" style="margin-top: 10px;">Tx: <a href="javascript:void(0)"
                    @click="openLink(sentTxHash)">{{ formatTx }}</a></h4>
                <Button :disabled="!hideSpin || walletMode ==='cold'" @click="modalMode = 'Deposit'; popModal = true;" type="primary"
                    style="width: 100px; margin-top: 20px; margin-left: 10px;">Deposit</Button>
                <Button v-if="walletMode === 'hot'" :disabled="!hideSpin" @click="modalMode = 'Withdraw'; popModal = true;" type="primary"
                    style="width: 100px; margin-top: 20px; margin-left: 10px;">Withdraw</Button>
                <Button v-if="walletMode === 'cold'" :disabled="!hideSpin" @click="modalMode = 'Sign'; popModal = true;" type="primary"
                    style="width: 100px; margin-top: 20px; margin-left: 10px;">Sign</Button>
                <!-- <Button :disabled="!hideSpin || walletMode ==='cold'" @click="modalMode = 'Transfer'; popModal = true;" type="primary"
                    style="margin-top: 20px; margin-left: 10px;">Transfer</Button> -->
                <Select :disabled="!hideSpin || walletMode ==='cold'" style="width:140px; margin-left: 10px; margin-top: 20px;" placeholder="Action" @on-select="selectAction">
                    <Option value="Transfer">Transfer</Option>
                    <Option value="FundsProof" disabled>Proof of funds</Option>
                    <Option value="DecryptBalance">Decrypt Balance</Option>
                    <Option value="DecryptAddress">Decrypt Address</Option>
                </Select>
            </div>
            <Spin fix v-show="!hideSpin">
                <Icon type="ios-loading" size=25 class="demo-spin-icon-load"></Icon>
                <div>Loading...</div>
            </Spin>
        </div>
        <Modal v-model="popModal" :footer-hide="hideFooter" class-name="vertical-center-modal">
            <p style="text-align: center;margin-bottom: 10px;"> 
                {{ modalMode }} {{ modalMode === "Transfer" ? " "+contractName:" "+coinName }}
            </p>
            <div v-if="modalMode === 'Sign'">
                <Input v-model="signTimestamp" type="text" style="margin-top: 20px;"
                placeholder="Enter the timestamp (milliseconds) of the offline signing."><span slot="prepend">Nonce</span></Input>
                <Input v-model="offlineSignature" type="text" style="margin-top: 20px;"
                    placeholder="Enter the offline signature generated by the cold wallet"><span slot="prepend">Signature</span></Input>
            </div>
            <div v-if="modalMode !== 'Sign'">
                <Row v-if="modalMode === 'Deposit'" style="width: 160px; margin-top: 20px;">
                    <Col span="17" style="margin-top: 5px;">
                        <span>HotWithdrawMax</span>
                    </Col>
                    <Col span="7">
                        <Input v-if="modalMode !== 'Withdraw'" v-model="hotWithdrawMax" type="text"
                        placeholder="Enter the cold wallet address"></Input>
                    </Col>
                </Row>
                <Input v-if="modalMode !== 'Withdraw'" v-model="inputWalletAddress" type="text" style="margin-top: 20px;"
                    placeholder="Enter the cold wallet address"><span slot="prepend">Wallet</span></Input>
                <Row style="margin-top: 20px;">
                    <Col span="22">
                        <Input v-model="inputAmount" type="text"><span slot="prepend">Amount</span></Input>
                    </Col>
                    <Col span="2" style="margin-top: 5px;">
                        <a href="javascript:void(0)" @click="walletBalance()" style="margin-left: 5px;">Max</a>
                    </Col>
                </Row>

            </div>
            <div style="text-align: center; margin-top: 15px;">
                <Button v-if="modalMode === 'Sign'" type="primary" @click="modalConfirm(offlineSign)"
                    style="margin-right: 10px;">Cold wallet sign</Button>
                <Button v-if="modalMode === 'Sign'" type="primary" @click="modalConfirm(walletSign)"
                    style="margin-right: 10px;">Hot wallet sign</Button>
                <Button v-if="modalMode === 'Deposit'" type="primary" @click="modalConfirm(deposit)"
                    style="margin-right: 10px;">Confirm</Button>
                <Button v-if="modalMode === 'Withdraw'" type="primary" @click="modalConfirm(withdraw)"
                    style="margin-right: 10px;">Confirm</Button>
                <Button v-if="modalMode === 'Transfer'" type="primary" @click="modalConfirm(transfer)"
                    style="margin-right: 10px;">Confirm</Button>
                <Button @click="popModal = false; modalReadonly = false;">Cancel</Button>
            </div>
        </Modal>
    </div>
</template>
<script>
    import { ethers } from "ethers";
    import SelfETHABI from "../datas/selfEth.json";
    export default {
        inject: ["reload"],
        data() {
            return {
                wallet: {},
                inputAmount: 0,
                inputWalletAddress: "",
                hotWithdrawMax: "0.3",

                instance: null,
                // hideSpin: true,
                hideSpin: false,
                eWalletBalance: "",
                eWalletAddress: "0x0000000000000000000000000000000000000000000000000000000000000000",
                formatEwalletBalance: "0x0000...0000",
                formatEwalletAddress: "0x0000...0000",

                coinName: "ETH",
                contractName: "SETH",
                selfETH: {
                    "0xaa36a7": "0x93c7534a82b80Ba72e7934d53A8be0259665E6ae",
                    "ABI": SelfETHABI,
                    contract: {}
                },
                formatTx: "",
                sentTxHash: '',
                privateBalanceOf: null,

                hideFooter: true,
                popModal: false,
                modalMode: 'deposit',

                walletMode: 'hot',
                action: 'Action',
                hotSign: false,
                signTimestamp: "",
                offlineSignature: ""
            }
        },
        mounted: function () {
            this.init();
        },
        methods: {
            openLink(tx) {
                window.open(`https://sepolia.etherscan.io//tx/${tx}`, '_blank');
            },
            init() {
                this.wallet = this.$parent.getWallet();
                this.$parent.getWallet().Init().then(async () => {
                    this.selfETH.contract = this.wallet.getContract(this.selfETH[this.wallet.chainId], this.selfETH.ABI);
                    await this.waitForInstance();
                    await this.updateBalance();
                    this.hideSpin = true;
                });
            },
            changewalletMode() {
                this.walletMode = this.$parent.activeWallet;
            },
            async selectAction(item) {
                try {
                    if (item.value === "DecryptBalance") {
                        this.hideSpin = false;
                        this.eWalletBalance = ethers.formatEther(await this.decrypt(this.eWalletBalance));
                        this.formatEwalletBalance = this.eWalletBalance + ' SETH';
                        this.hideSpin = true;
                    } else if (item.value === "DecryptAddress") {
                        this.hideSpin = false;
                        this.eWalletAddress = await this.decrypt(this.eWalletAddress);
                        this.formatEwalletAddress = this.wallet.formatAddress(this.eWalletAddress, 4);
                        this.hideSpin = true;
                    } else {
                        this.modalMode = item.value;
                        this.popModal = true;
                    }
                } catch(err) {
                    this.hideSpin = true;
                }
            },
            async sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },
            async waitForInstance() {
                while (window.fheInstance == undefined) {
                    await this.sleep(100);
                }
            },
            async walletBalance() {
                this.inputAmount = await this.wallet.getBalance();
            },
            async updateBalance() {
                try {
                    const walletAddress = ethers.getAddress(this.wallet.getAccount());
                    const coldHash = await this.selfETH.contract.getColdHash(walletAddress);
                    let eaddr = coldHash; //await this.selfETH.contract.privateAddress(coldHash);
                    console.log("get privateAddress ok:", eaddr);
                    if (eaddr !== "0x0000000000000000000000000000000000000000000000000000000000000000") {
                        this.eWalletAddress = eaddr;
                        this.eWalletBalance = await this.selfETH.contract.privateBalance();
                        this.formatEwalletBalance = this.wallet.formatAddress(this.eWalletBalance, 4);
                        // this.eWalletBalance = ethers.formatEther(await this.decrypt(this.eWalletBalance));
                        this.formatEwalletAddress = this.wallet.formatAddress(this.eWalletAddress, 4);
                    }
                } catch (err) {
                    console.log("update balance failed, error: ", err)
                    // this.inputWalletAddress = walletAddress;
                }
            },
            modalConfirm(func) {
                let self = this;
                this.popModal = false;
                this.hideSpin = false;
                new Promise(async (resolve, reject) => {
                    try {
                        const txhash = await func();
                        if (txhash !== "") {
                            self.sentTxHash = txhash;
                            self.formatTx = self.wallet.formatAddress(txhash, 12);
                            await self.updateBalance();
                        }
                        self.hideSpin = true;
                    } catch (err) {
                        console.log(`${this.modalMode} failed, error: ${err}`)
                        this.$Message.error({
                            content: `send tx failed, error: ${err.message}`,
                            closable: true,
                            duration: 10
                        });
                        this.signTimestamp = "";
                        this.offlineSignature = "";
                        self.hideSpin = true;
                    }
                });
            },
            async deposit() {
                if (this.inputWalletAddress === "") {
                    this.$Message.warning('Please enter the cold wallet address');
                    return "";
                }
                const hotWithdrawMax = parseFloat(this.hotWithdrawMax);
                const inputAmount = ethers.parseEther(this.inputAmount);
                const coldAddress = ethers.getAddress(this.inputWalletAddress);
                const coldHash = await this.selfETH.contract.getColdHash(coldAddress);
                const walletAddress = ethers.getAddress(this.wallet.getAccount());
                // const ciphertexts = await this.encrypt(coldAddress);
                // console.log(ciphertexts, coldHash)

                const gasLimit = await this.selfETH.contract.privateDeposit.estimateGas(coldHash, BigInt(hotWithdrawMax * 100));
                let options = { from: walletAddress, value: inputAmount, gasLimit: BigInt(gasLimit), gasPrice: (await this.wallet.provider.getFeeData()).gasPrice };//, nonce: nonce}
                const sentTx = await this.selfETH.contract.privateDeposit(coldHash, BigInt(hotWithdrawMax * 100), options);
                await sentTx.wait(1);
                return sentTx.hash;
            },
            async withdraw() {
                let self = this;
                if (this.signTimestamp === "") {
                    this.$Modal.confirm({
                        title: 'Switch to offline signing',
                        content: '<p>Offline signature not yet generated, switch to offline signing by cold wallet</p>',
                        onOk: () => {
                            self.$parent.selectWallet({value: 'cold'});
                            // self.walletMode = 'cold';
                            self.modalMode = 'Sign'; 
                            self.popModal = true;
                        }
                    });
                    return "";
                }
                const walletAddress = ethers.getAddress(this.wallet.getAccount());
                const signMessage = ethers.toUtf8Bytes(`${this.signTimestamp}`);
                // const ciphertexts = await this.encrypt(coldAddress);
                
                if (this.hotSign) {
                    this.signTimestamp = "";
                    const gasLimit = await this.selfETH.contract.privateWithdraw.estimateGas(ethers.parseEther(this.inputAmount));
                    let options = { from: walletAddress, gasLimit: BigInt(gasLimit), gasPrice: (await this.wallet.provider.getFeeData()).gasPrice };//, nonce: nonce}
                    const sentTx = await this.selfETH.contract.privateWithdraw(ethers.parseEther(this.inputAmount), options);
                    await sentTx.wait(1);
                    return sentTx.hash;
                } else {
                    const gasLimit = await this.selfETH.contract.privateWithdrawForCold.estimateGas(this.offlineSignature, signMessage, ethers.parseEther(this.inputAmount), BigInt(this.signTimestamp));
                    let options = { from: walletAddress, gasLimit: BigInt(gasLimit), gasPrice: (await this.wallet.provider.getFeeData()).gasPrice };//, nonce: nonce}
                    const sentTx = await this.selfETH.contract.privateWithdrawForCold(this.offlineSignature, signMessage, ethers.parseEther(this.inputAmount), BigInt(this.signTimestamp), options);
                    await sentTx.wait(1);
                    return sentTx.hash;
                }
            },
            async transfer() {
                if (this.inputWalletAddress === "") {
                    this.$Message.warning('Please enter the destination wallet address');
                    return "";
                }
                if (parseFloat(this.inputAmount) <= 0) {
                    this.$Message.warning('Please enter the valid amount');
                    return "";
                }
                const inputAddr = ethers.getAddress(this.inputWalletAddress);
                const inputAmount = ethers.parseEther(this.inputAmount);
                const walletAddress = ethers.getAddress(this.wallet.getAccount());
                const inputColdHash = await this.selfETH.contract.getColdHash(inputAddr);

                const ciphertexts = await this.encrypt("", inputAmount, true);
                console.log("ciphertexts", ciphertexts)

                const gasLimit = await this.selfETH.contract.privateTransfer.estimateGas(inputColdHash, ciphertexts.handles[0], ciphertexts.inputProof);
                console.log("before transfer, gasLimit:", gasLimit)
                let options = { from: walletAddress, value: BigInt(0), gasLimit: BigInt(300000), gasPrice: (await this.wallet.provider.getFeeData()).gasPrice };//, nonce: nonce}
                const sentTx = await this.selfETH.contract.privateTransfer(inputColdHash, ciphertexts.handles[0], ciphertexts.inputProof, options);
                await sentTx.wait(1);
                return sentTx.hash;
            },
            async fundsProof() {
                this.$Message.warning('Not supported at present');
            },
            async encrypt(coldAddress, amount, bTransfer) {
                const walletAddress = ethers.getAddress(this.wallet.getAccount());
                const contractAddress = ethers.getAddress(this.selfETH[this.wallet.chainId]);
                console.log("=======", coldAddress, contractAddress, walletAddress)

                // We first create a buffer for values to encrypt and register to the fhevm
                let buffer = await window.fheInstance.createEncryptedInput(
                    // The address of the contract allowed to interact with the "fresh" ciphertexts
                    contractAddress,
                    // The address of the entity allowed to import ciphertexts to the contract at `contractAddress`
                    walletAddress,
                )
                if (coldAddress !== "") buffer = buffer.addAddress(coldAddress);
                if (amount !== undefined) buffer.add128(amount);
                const ciphertexts = await buffer.encrypt();
                console.log("ciphertexts", ciphertexts)
                return ciphertexts;
            },
            async decrypt(ciphertextHandle) {
                const contractAddress = ethers.getAddress(this.selfETH[this.wallet.chainId]);
                const keypair = window.fheInstance.generateKeypair();
                const handleContractPairs = [
                    {
                        handle: ciphertextHandle,
                        contractAddress: contractAddress,
                    },
                ];
                const startTimeStamp = Math.floor(Date.now() / 1000).toString();
                const durationDays = '10'; // String for consistency
                const contractAddresses = [contractAddress];

                console.log("before decrypt: ", ciphertextHandle, contractAddress)

                const eip712 = window.fheInstance.createEIP712(
                    keypair.publicKey,
                    contractAddresses,
                    startTimeStamp,
                    durationDays,
                );

                const signer = this.wallet.signer;
                const signature = await signer.signTypedData(
                    eip712.domain,
                    {
                        UserDecryptRequestVerification: eip712.types.UserDecryptRequestVerification,
                    },
                    eip712.message,
                );

                const result = await window.fheInstance.userDecrypt(
                    handleContractPairs,
                    keypair.privateKey,
                    keypair.publicKey,
                    signature.replace('0x', ''),
                    contractAddresses,
                    signer.address,
                    startTimeStamp,
                    durationDays,
                );
                const decryptedValue = result[ciphertextHandle];
                return decryptedValue;
            },
            async offlineSignx() {
                let self = this;
                if (this.signTimestamp === "" || this.offlineSignature === "") {
                    this.$Message.warning('Please enter the timestamp of the cold wallet signing and the generated offline signature');
                    return "";
                }
                this.$Modal.confirm({
                    title: 'Ready to withdraw',
                    content: '<p>Offline signing complete. Switch to hot wallet to withdraw</p>',
                    onOk: () => {
                        self.$parent.selectWallet({value: 'hot'});
                        self.modalMode = 'Withdraw'; 
                        // self.walletMode = 'hot';
                        self.popModal = true;
                    }
                });
                return "";
            },
            async walletSign() {
                this.signTimestamp = Date.now();
                this.hotSign = true;
                this.$parent.selectWallet({value: 'hot'});
                this.modalMode = 'Withdraw';
                this.popModal = true;
                return "";
            },
            async offlineSign() {
                let self = this;
                const timestamp = Date.now();
                const walletAddress = ethers.getAddress(this.wallet.getAccount());

                var msgParams = [
                    {
                        type: 'string',
                        name: 'Action',
                        value: `${timestamp}`
                    }
                ]
                const signResult = await window.ethereum.request({
                    method: "eth_signTypedData",
                    params: [msgParams, walletAddress],
                    from: walletAddress
                });
                // const coldAddress = await this.selfETH.contract.walletSignatureVerify(signResult, ethers.toUtf8Bytes(`${timestamp}`));
                // console.log("coldAddress:", coldAddress)

                if (signResult.indexOf("0x") === 0) {
                    this.signTimestamp = timestamp;
                    this.offlineSignature = signResult;

                    this.$Modal.confirm({
                        title: 'Ready to withdraw',
                        content: '<p>Offline signing complete. Switch to hot wallet to withdraw</p>',
                        onOk: () => {
                            self.$parent.selectWallet({value: 'hot'});
                            self.modalMode = 'Withdraw'; 
                            // self.walletMode = 'hot';
                            self.popModal = true;
                        }
                    });
                }
                return "";
            }
        }
    }
</script>